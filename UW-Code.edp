/*
WavePropagation Code

Solution of the wave propagation problem in a aluminum plate from a pulse emitted at the left end of the plate.
The displacement u = (ux, uy) of each point on the plate in time is calculated.
u depending on the temporal variable t and the spatial variables (x, y).
The problem is solved using FEM for the spatial variables (x, y) and the Houbolt method (2nd order finite differences)
to approximate the second derivative of the displacement vector

h- mesh size (m).

///////////////////////////////////////////////////////////////////////////////////////////
Input:
f0 - frequency (Hz). Use a frequency value in the interval [1 , 30]x10^5 Hz.  

Output
The program returns several files at the output:
x.txt, y.txt
ux.txt, uy.txt
The files ux.txt and uy.txt contain the values ​​at the points (x, y) (which appear in the files x.txt and y.txt)
of the functions ux and uy that define the displacement of each point on the plate for a t-FIXED time. 
That time in the code is called t1. In addition there are 4 files uyP1.txt, uyP2.txt, uyP3.txt and uyP4.txt. 
These files contain the values ​​of the second component of the displacement evaluated at 4 fixed points P1, P2, P3 and P4 
for a sequence of values ​​of time ti = i * dt, that is, uy(P1, ti), uy(P2, ti ), uy(P3, ti) and uy(P4, ti).
*///////////////////////////////////////////////////////////////////////////////


cout<<"WavePropagation Code"<<endl;
cout<<endl;
cout<<"Solution of the wave propagation problem in a aluminum plate from a pulse emitted at the left end of the plate."<<endl;
cout<<"The displacement u = (ux, uy) of each point on the plate in time is calculated."<<endl;
cout<<"u depending on the temporal variable t and the spatial variables (x, y)."<<endl;
cout<<"The problem is solved using FEM for the spatial variables (x, y) and the Houbolt method (2nd order finite differences) to approximate the second derivative of the displacement vector."<<endl;
cout<<endl;
cout<<"Input:"<<endl;
cout<<"f0 - frequency (Hz). Use a frequency value in the interval [1 , 30]x10^5 Hz."<<endl;
cout<<endl;
cout<<"Output"<<endl;
cout<<"The program returns several files at the output:"<<endl;
cout<<"x.txt, y.txt"<<endl;
cout<<"ux.txt, uy.txt"<<endl;
cout<<"The files ux.txt and uy.txt contain the values at the points (x, y) (which appear in the files x.txt and y.txt)"<<endl;
cout<<"of the functions ux and uy that define the displacement of each point on the plate for a t-FIXED time."<<endl;
cout<<"That time in the code is called t1. In addition there are 4 files uyP1.txt, uyP2.txt, uyP3.txt and uyP4.txt."<<endl;
cout<<"These files contain the values of the second component of the displacement evaluated at 4 fixed points P1, P2, P3";
cout<<"and P4 for a sequence of values of time ti = i * dt, that is, uy(P1, ti), uy(P2, ti ), uy(P3, ti) and uy(P4, ti)."<<endl;
cout<<endl;
cout<<endl;

real cpu=clock();
real  t=0,       								      // Initial time
rho=2700,                 									 // Density (Kg/m^3)
P=0.334,                     									  //Poisson Ratio
E=7e10;                    									  // Young's modulus (N/m^2)


real mu=(E/(2*(1+P))), lambda=(E*P/((1+P)*(1-2*P)));   				  // Lamé's constants


// Parameters for pulse g that depend on f0
real amp=1e-3,
dt,    
Tend,     
f0=0;
while(f0<1e5 || f0>30e5){

cout<<"Choose a frequency f0 in the interval [1 , 30]x10^5 Hz"<<endl;
cout<<"f0= ";
cin>>f0;

}



real delta; 	

 // dt- delta_t (seg) step for temporal discretization.
 if(f0>3e5){
	 dt=1e-8;
 }else{
	 dt=1e-7;
 }
 
 
 if(f0>=1e5&&f0<=2e5){
	 Tend=5.5e-5;
	 delta=1.3;
 }
 if(f0>2e5&&f0<=3e5){
	 Tend=3.5e-5;
	 delta=1.3;
 }
 if(f0>3e5&&f0<=9e5){
	 Tend=1.5e-5;	
	 delta=0.4;
 }
 if(f0>9e5){
	 Tend=1.2e-5;
	 delta=0.3;
 }
 
 real g;

cout<<"Dt= "<<dt<<"seg"<<endl;        						

//////////////////////////////////////////////////////////////////////////////////////

real Ly=0.001, Lx=0.05;				// Plate dimensions (m).

	
	
real ny; 

if(f0>6e5){
	ny=15;
}else{
	ny=6;
}
	

real nx=(ny*Lx)/Ly;      	 
mesh Sh=square(nx,ny,[Lx*x,Ly*y]); 								// Generate the mesh

// plot(Sh, wait=1);		//If you want see the mesh uncomment

///////////////////////////////////////////////////////////////////////////////////////

macro u [u1,u2]       										 // Solution u
macro up [up1,up2]     										// Last step u_(i-1)
macro upp [upp1,upp2]   									  // Last step u_(i-2)
macro uppp [uppp1,uppp2]   									  // Last step u_(i-3)
macro v [v1,v2]     										// Test function v
macro sigma [(lambda*(dx(u1)+dy(u2))+2*mu*dx(u1)),(mu*(dy(u1)+dx(u2))),(lambda*(dx(u1)+dy(u2))+2*mu*dy(u2))] 	// stress matrix

//// Define the problem ////////////////////////////////////////////////////////////
fespace Vh(Sh,[P2,P2]);  									//Build the solutions space
int ng = Vh.ndof;											//Number of Degrees of Freedom
cout << "Degree of freedom = "<< ng <<endl;					
fespace Ph(Sh,P2);
Ph h1 = hTriangle;			
cout << "size = "<< h1[].max <<endl;						
Vh 	u, v, upp=[0,0],up=[0,0],uppp=[0,0];  						
 
//Variational Formulation a(u,v)-F(v)=0
problem FormVar(u,v )=
int2d(Sh)(2*rho*(u')*v +(dt^2)*(sigma[0]*dx(v[0])+ sigma[1]*(dy(v[0])+dx(v[1]))+ sigma[2]*dy(v[1]))) 	
-int2d(Sh)(rho*(5*(up')*v - 4*(upp')*v + (uppp')*v))		
+on(4,u1=0,u2=g); 											



problem Estacionario(u,v )=
		int2d(Sh)(rho*(u')*v+(dt^2)*(sigma[0]*dx(v[0])+ sigma[1]*(dy(v[0])+dx(v[1]))+ sigma[2]*dy(v[1])))
		-int2d(Sh)(rho*(2*(up')*v-(upp')*v))
		+on(4,u1=0,u2=g);  					

//// Save solution //////////////////////////////////////////////////////////////

// Output values for the calculation of the phase velocity
ofstream f("uyP1.txt");
ofstream ff("uyP2.txt");
ofstream fff("uyP3.txt");
ofstream ffff("uyP4.txt");

// Output values for the error calculation
ofstream fu1("ux.txt");
ofstream fu2("uy.txt");
ofstream fy("y.txt");
ofstream fx("x.txt");

real n=0, j, m=50, mx=50, dim=(Tend/dt),
	 t1=0.699e-5;								// Time set to calculate the error


real[int] xx(dim),uyp1(dim),uyp2(dim),uyp3(dim),uyp4(dim);
real s1=5;
real[int] s;

// Gaussian squares values
if(s1==1){
 s = [0];
}
if(s1==2){
 s = [-0.577350269189626,0.577350269189626];
}
if(s1==3){
 s = [-0.774596669241000,0,0.774596669241000];
}
if(s1==4){
 s = [-0.861136311594053,-0.339981043584856,0.339981043584856,0.861136311594053];
}
if(s1==5){
 s = [-0.906179845938664,-0.538469310105683,0,0.538469310105683,0.906179845938664];
}


int i=0;
 // Cycle in time with size dt
 for(real t=0;t<=Tend;t+=dt){
	
	xx[i]=t;
		
	if(t<=(5/f0)){
		g=amp*sin(2*pi*f0*t)*exp(-1*(f0*t-2.5)^2);				// Function that describes the pulse
	}else{
		g=0;
	}
	
	if(i<1){
		Estacionario;
			
	///////////////////////////////////////////////////////////////////////////////////////////////
		uyp1[i]=u2(0.01,Ly);uyp2[i]=u2(0.013,Ly);uyp3[i]=u2(0.016,Ly);uyp4[i]=u2(0.019,Ly);
		f<<u2(0.01,Ly)<<endl;               
		ff<<u2(0.013,Ly)<<endl;            
		fff<<u2(0.016,Ly)<<endl;          
		ffff<<u2(0.019,Ly)<<endl;         
	////////////////////////////////////////////////////////////////////////////////////////////////
		upp=up;													// change the values of u_(i-2)
		up=u;													// change the values of u_(i-1)
		i++;
	}else{

	FormVar;							// Call the Variational Formulation and solve it, returning the values of u = [u1, u2]

	
///////////////////////////////////////////////////////////////////////////////////////////////
	uyp1[i]=u2(0.01,Ly);uyp2[i]=u2(0.013,Ly);uyp3[i]=u2(0.016,Ly);uyp4[i]=u2(0.019,Ly);
	f<<u2(0.01,Ly)<<endl;               
	ff<<u2(0.013,Ly)<<endl;            
	fff<<u2(0.016,Ly)<<endl;          
	ffff<<u2(0.019,Ly)<<endl;           
////////////////////////////////////////////////////////////////////////////////////////////////
  
/* delta=1e7; 											
 real minT0= checkmovemesh(Sh,[x,y]); 						
while(1) 													
{
real minT=checkmovemesh(Sh,[x + delta*u1, y + delta*u2]); 	
if ( minT0/1.5<minT) break ; 								
delta/=1.5;
 } */
 
mesh Th=movemesh(Sh,[x+delta*u1,y+delta*u2]);  				

////////////////////////////////////////////////////////////////////////////////////////////
fespace Wh(Th,P2);
Wh M;

M=u2;
 
	if(abs(t-t1)<dt & n!=1){
		n = 1;
		real[int] yy(m*s1);
		real a, b, xmin, xmax;
		xmin=0.91e-2; xmax=1.08e-2;  		// [xmin, xmax] interval where the error is calculated


	//************** Eje X *****************************************************************//
		for (int jx=0;jx<mx;jx+=1){
			real ax=xmin + (xmax-xmin)*jx/mx, bx=xmin + (xmax-xmin)*(jx+1)/mx;
			for (int jjx=0;jjx<s1;jjx+=1){
				real xx1=((bx-ax)*s[jjx]/2)+ (bx+ax)/2;
				fx<<xx1<<endl;				// Save the values of x

	//************** Eje Y ***********************************************************//
				int k=0;
				for (j=0;j<m;j+=1){
					if (jjx==0 && jx==0){ 
						a=Ly*j/m;
						b=Ly*(j+1)/m; 	
					}
					for (int jj=0;jj<s1;jj+=1){

//*********************************************************//

						if (jjx==0 && jx==0){
							yy[k]=((b-a)*s[jj]/2)+ (b+a)/2;   
							fy<<yy[k]<<endl;   				// Save the values of y
						}

//*********************************************************//

						fu2<<u2(xx1,yy[k])<<endl;              // Save the solution u_y(x, y) for the instant of time t1

						fu1<<u1(xx1,yy[k])<<endl;              // Save the solution u_x (x, y) for the instant of time t1
						k=k+1;
					}
				}
			}
		}
	}


 

//////////////////////////////////////////////////////////////////////////////////////////////
	if(abs(t-Tend)<=dt){
		plot(Th,M,nbiso=30,value=1,fill=1,wait=1,cmm="Wave propagation in aluminum plate for the frequency of "+ f0+" Hz; time t="+t+". Type Enter key to continue.",aspectratio=1,bb=[[-1e-3,-2e-3],[6e-2,3e-3]],dim=2 );
	}else{
		plot(Th,M,nbiso=30,value=1,fill=1,wait=0,cmm="Wave propagation in aluminum plate for the frequency of "+ f0+" Hz; time t="+t,aspectratio=1,bb=[[-1e-3,-2e-3],[6e-2,3e-3]],dim=2 );
	}
	
	///// // change the initial values ////////////////////////////////////////////////////////////
	uppp=upp;
	upp=up;
	up=u;
	i++;
	}
}
plot([xx,uyp1],cmm="Graphic of the displacement in the vertical direction uy(t, P1) of the selected points P1 = (0.01, Ly) for f0 = " +f0+" Hz. Type Enter key to continue.",wait=true);
plot([xx,uyp2],cmm="Graphic of the displacement in the vertical direction uy(t, P2) of the selected points P2 = (0.013, Ly) for f0 = " +f0+" Hz. Type Enter key to continue.",wait=true);
plot([xx,uyp3],cmm="Graphic of the displacement in the vertical direction uy(t, P3) of the selected points P3 = (0.016, Ly) for f0 = " +f0+" Hz. Type Enter key to continue.",wait=true);
plot([xx,uyp4],cmm="Graphic of the displacement in the vertical direction uy(t, P4) of the selected points P4 = (0.019, Ly) for f0 = " +f0+" Hz. Type Esc key tu exit.",wait=true);
cout << " CPU time = " << clock()-cpu << endl;